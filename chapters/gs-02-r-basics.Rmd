# (PART) R Basics {.unnumbered}

# Data Structure

## Overview

R has 6 basic **data types**.

-   character: `"aquatic"`, `"ecology"` (no order)
-   factor: similar to character, but has *levels* (alphabetically ordered by default)
-   numeric: `20.0` , `15.5`
-   integer: `3`, `7`
-   logical: `TRUE` , `FALSE`
-   complex: `1+2i` (complex numbers with real and imaginary parts)

These elements form one of the following **data structures**.

-   **vector**: a series of elements. A single data type is allowed in a single vector
-   **matrix**: elements organized into rows and columns. A single data type is allowed in a single matrix
-   **dataframe**: looks similar to a matrix, but allows different data types in different columns

## Vector

### Create Vector

Below are examples of atomic character vectors, numeric vectors, integer vectors, etc. There are many ways to create vector data. The following examples use `c()`, `:`, `seq()`, `rep()`:

**Combine function** `c()` combines multiple elements to create a single vector.

```{r, echo=TRUE}

# ex.1a manually create a vector using c()
(x <- c(1, 3, 4, 8))

# ex.1b character
(x <- c("a", "b", "c"))

# ex.1c logical
(x <- c(TRUE, FALSE, FALSE))

```

**Replicate function** `rep()` replicates the same element(s) multiple times.

```{r, echo=TRUE}
# ex.3a replicate same numbers or characters
(x <- rep(2, times = 5)) # replicate 2 five times

# ex.3b replicate same numbers or characters
(x <- rep("a", 5)) # replicate "a" five times

# ex.3c replicate each element multiple times
(x <- rep(c(1, 2), each = 2))
```

**Sequence function** `seq()` creates a vector base on starting and ending values with a specified interval or a vector length.

```{r, echo=TRUE}
# ex.4a use seq() function
# create a vector from 1 to 5 with intervel 1
(x <- seq(1, 5, by = 1))

# ex.4b use seq() function
# create a vector from 1 to 5 with 20 elements
(x <- seq(1, 5, length = 20))
```

### Extract Summary

Numerical or character information can be summarized using functions. Let's try basic functions to see how it works:

**Mean function** `mean()` calculates the arithmetic mean.

```{r}
x <- c(10, 15, 20)
mean(x)
```

**Sum function** `sum()` calculates the summation.

```{r}
x <- c(10, 15, 20)
sum(x)
```

**Length function** `length()` returns the number of elements in a vector.

```{r}
x <- c(10, 15, 20)
length(x)
```

### Access

**Element ID** Use brackets `[]` when accessing specific elements in an object. For example, if you want to access element #2 in the vector `x`, you may specify as `x[2]`:

```{r}
x <- c(2, 2, 3, 2, 5)
x[2] # access element #2
x[c(2, 4)] # access elements #2 and 4
x[2:4] # access elements #2-4
```

**Equation** R provides many ways to access elements that meet specific conditions. You can use mathematical symbols to specify what you need, for example:

-   `==` equal
-   `>` larger than
-   `>=` equal & larger than
-   `<` smaller than
-   `<=` equal & smaller than
-   `which()` a function that returns element \# that suffices the specified condition

The following examples return a logical vector indicating whether each element in `x` suffices the specified condition:

```{r, echo=TRUE}

# creating a vector
x <- c(2, 2, 3, 2, 5)

# ex.1a equal
x == 2

# ex.1b larger than
x > 2 

```

You can access elements that meet the specified condition using brackets, for example:

```{r, echo=TRUE}

# ex.2a equal
x[x == 2]
# ex.2b larger than
x[x > 2]

```

Using `which()`, you can see which elements (i.e., \#) matches what you need:

```{r, echo=TRUE}

# ex.3a equal
which(x == 2) # returns which elements are equal to 2

# ex.3b larger than
which(x > 2)

```

### Caveat

A single vector CANNOT contain multiple types of data. For example, try the following code. R coerced `x` into a character vector, not numeric.

```{r, echo=TRUE}
(x <- c(1, 2, "a"))

## class() returns a data type of an object
class(x)
```

Also, the character data type is not limited to letters; numbers can be character, when double-quoted. For example, you cannot calculate the mean of the following vector because the numbers are recognized as character in R.

```{r, echo=TRUE}
## enter numbers as character "1" "2"
(x <- c("1", "2"))

## class() returns a data type of an object
class(x)

## cannot calculate the mean
mean(x)
```

### Exercise

a.  Create three numeric vectors with length 3, 6 and 20, respectively. The three vectors must be created using different functions (`c()`, `rep()`, `seq()`).
b.  Create two character vectors with length 3 and 20, respectively. The two vectors must be created using two different functions (`c()`, `rep()`).
c.  Copy the following script to your R script and perform the following analysis:

```{r, eval = FALSE}
set.seed(1)
y <- rnorm(100)
```

-   Identify element IDs of `y` that are greater than `2.0`
-   Identify element values of `y` that are greater than `2.0`
-   Calculate the arithmetic mean of `y`

## Matrix

### Create Matrix

Matrix is a set of elements (*single data type*) that are organized into rows and columns:

**Column bind function** `cbind()` combines two vectors by column.

```{r, echo=TRUE}
## numeric
(m_x <- cbind(c(1,2,3), c(4,5,6)))

## character
(m_x <- cbind(c("a", "b", "c"), c("d", "e", "f")))
```

**Row bind function** `rbind()` combines two vectors by row.

```{r, echo=TRUE}
## numeric
(m_x <- rbind(c(1, 2, 3), c(4, 5, 6)))

## character
(m_x <- rbind(c("a", "b", "c"), c("d", "e", "f")))
```

**Matrix function** `matrix()` organize a vector into a matrix by specifying the numbers of rows and columns

```{r, echo=TRUE}
## numeric: vector 1:9 is organized into 3 x 2 matrix
(m_x <- matrix(1:9, nrow = 3, ncol = 2))

(m_x <- matrix(c("a", "b", "c",
                 "d", "e", "f"),
               nrow = 3,
               ncol = 2))
```

### Access

**Element ID** When accessing matrix elements, you need to pick row(s) and/or column(s).
In brackets, specify row ID(s) before comma, column ID(s) after comma (`[row ID, column ID]`). For example:

```{r, echo=TRUE}

(m_x <- matrix(1:9, nrow = 3, ncol = 3))

m_x[2, 3] # access an element in row #2 and column #3

m_x[2,] # access elements in row #2

m_x[c(2, 3),] # access elements in rows #2 and #3

m_x[,c(2, 3)] # access elements in columns #2 and #3

```

**Equation** You can assess each element with mathematical expressions just like vectors:

```{r, echo=TRUE}

m_x == 2 # equal

m_x > 2 # larger than

```

However, care must be taken when accessing elements, as it will be converted to vector data:

```{r}

m_x[m_x == 2] # equal

m_x[m_x > 2] # larger than

```

`which()` needs an additional argument to return both row and column #:

```{r}

which(m_x == 2, arr.ind = TRUE)

which(m_x > 2, arr.ind = TRUE)

```

### Exercise

### Matrix

a.  Create a numeric matrix with 4 rows and 4 columns using either `rbind()` or `cbind()` function.
d.  Create a character matrix with 4 rows and 4 columns using `matrix()` function.
e.  Copy the following script to your R script and perform the following analysis:

```{r, eval = FALSE}
set.seed(1)
x <- matrix(rnorm(100), nrow = 10, ncol = 10)
```

-   Identify element IDs of `x` that are greater than `2.0` (**specify row and column IDs**)
-   Identify element values of `x` that are greater than `2.0` and calculate the mean of the selected elements.

## Data Frame

A data frame is a collection of elements organized into rows and columns, but it differs from a matrix in several ways.

-   It allows for the inclusion of *multiple data types* in different columns.
-   Each column in a data frame has a *name* associated with it.
-   You can access columns in a data frame by their respective names using the `$` operator.

The data frame is the most commonly used data structure when manipulating ecological data. When loading a dataset from a spreadsheet (which we will discuss later), it is automatically recognized as a data frame. Let's consider an example:

### Creating a data frame
In the following example, the variables `x` and `y` are organized into a single data frame named `df0`. The variables are renamed as part of the process of creating the data frame.

```{r, echo=TRUE}
# Create data frame

# Lake type
x <- c("Pristine", "Pristine", "Disturbed", "Disturbed", "Pristine")

# TSS: total suspended solids (mg/L)
y <- c(1.2, 2.2, 10.9, 50.0, 3.0)

# x is named as "LakeType" while y is named as "TSS"
(df0 <- data.frame(LakeType = x, TSS = y))
```

### Access by columns

To access elements by column names, use `$` after the dataframe, then column name.

```{r, echo=TRUE}
df0$LakeType # access LakeType
df0$TSS # access TSS
```

You can access elements like a matrix as well:

```{r, echo=TRUE}

df0[, 1] # access column #1
df0[1, ] # access row #1
df0[c(2, 4),] # access row #2 and 4

```

### Exercise

Copy the following script to your R script and perform the following analysis:

```{r, eval = FALSE}
set.seed(1)
x <- rnorm(100, mean = 10, sd = 3)
y <- rpois(100, lambda = 10)
z <- rep(c("VA", "NC"), 50)
df0 <- data.frame(temperature = x, abundance = y, state = z)
```

-   Access `temperature` column.
-   Calculate the means of `temperature` and `abundance` for states `VA` and `NC` separately.

