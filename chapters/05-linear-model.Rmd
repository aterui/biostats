# Linear model

Many of you might hate equation -- I hated too because no one told me how to read it. However, you will like it once you understand how to interpret; it is actually the clearest explanation. In this section, I will continue to use the example of fish counts in a lake to explain the use of linear models.

## Modeling mean

### Linear model `lm()`

In the example of fish counts, we estimated mean and variance to infer how fish counts distribute over a range of possible values (probability distribution). Implicitly, I assumed that the "true" mean -- i.e., the expected number of fish counts in a plot -- is uniform within the lake. Let's express this assumption as a "model." Let $y_i$ be fish count in plot $i$:

$$
y_i = \mu + \varepsilon_i
$$

The above equation reads fish count $y_i$ can be expressed as the sum of mean density $\mu$ and residual $\varepsilon_i$ (raw deviation from the mean; $\varepsilon_i = y_i - \mu$). Notice that the parameter $\mu$ does not have subscript $i$ (i.e., $\mu$ is constant across plots) since we assume that the mean fish count is uniform across plots.

We can build this model pretty easily in R using function `lm()` (Linear Model, LM) with caution that this function assumes a Normal distribution, which we identified as an inappropriate distribution for our fish data. However, let me use this function for the sake of explanation. In the function `lm()`, we write a **response** variable (i.e., the variable we want to explain = fish count) on the left side of tilde `~`, and **explanatory** variables (or predictors) on the right. In our simplest model, we do not have explanatory variables, so put `1` on the right.

```{r lm, echo = T}

fit <- lm(count ~ 1, data = df_count)
summary(fit)
```

This is perhaps the simplest model we can make -- the variation in fish count $y_i$ can be expressed as the mean $\mu$ plus random variation $\varepsilon_i$. However, where is the mean in the output? In the model output, the estimated mean is shown in the column `Estimate` under the area `Coefficients:`. We can prove it by comparing the estimate and the mean of fish count calculated with function `mean()`.

> **Exercise:** calculate mean fish count with `mean()`

Next, where is $\varepsilon_i$? You can get values of $\varepsilon_i$ using function `resid()`, which stands for **residuals**.

```{r resid, echo=TRUE}

eps <- resid(fit)
print(eps)
```

It is unclear how this is derived, so let's compare it with $y_i - \mu$. Note that SD of the residual ($\text{SD} = \sqrt{\text{Variance}}$) is the degree of variation in the data, and the value `Residual standard error:` should match `eps`'s SD.

> **Exercise:** calculate $y_i - \mu$ and compare it with `eps`. Also, calculate the SD of `eps` and compare it with the reported value `Residual standard error:` in the `lm()` output.

The above model can be written in many ways. I strongly encourage you to know the following expression:

$$
y_i \sim \text{Normal}(\mu, \sigma^2)
$$

The interpretation of this equation is that $y_i$ follows a normal distribution with a mean $\mu$ and variance $\sigma^2$. When the left and right hands of the equation are related with tilde, it indicates the relationship is stochastic -- the outcome $y_i$ always deviates from the expectation $\mu$, unlike equal sign $y_i = \mu$, and the degree of deviation is controlled by $\sigma^2$. This expression is identical to the following:

$$
y_i = \mu + \varepsilon_i\\
\varepsilon_i \sim \text{Normal}(0, \sigma^2)
$$

This clarifies that the deviation $\varepsilon_i$ is stochastic, but the expectation $\mu$ is deterministic. This is the basic structure of statistical model -- **observation is a mix of deterministic and stochastic components**.

### Generalized linear model `glm()`

In the previous section, we have identified that fish count is better described by a Poisson distribution. How can we fit a model with a Poisson distribution to the data? R has functionality to perform this type of analysis, and Generalized Linear Model (GLM) (`glm()`) is the natural extension of `lm()` function for non-normal distributions. It's pretty easy to use:

```{r glm, echo = TRUE}

fit_pois <- glm(count ~ 1, data = df_count, family = "poisson")
```

The only difference is that we used the function `glm()` and specified a Poisson distribution as `family = "poisson"`. Let's see what's in there.

```{r glm-summary, echo = TRUE}
summary(fit_pois)
```

Wait...it says `Estimate` `r round(fit_pois$coefficients, 2)`, which is quite different from what we see in our fish count data (mean = `r round(mean(df_count$count), 2)`). What's going on? This is because there is internal variable transformation when a Poisson distribution is used. Since a Poisson distribution deals with positive integer (including zero), its mean cannot be negative. To avoid this potential problem in some data sets, the function `glm()` estimates the mean after log-transformation, and then back-transform to an ordinary scale. The reported value is in a natural log-scale -- we can retrieve the mean estimate in an ordinary scale by transforming the estimate by exponent `exp()` .

```{r exp-poisson, echo = T}

# get intercept value in a log-scale
fit_pois$coefficients

# transform to an ordinary scale
exp(fit_pois$coefficients)
```

The Poisson model can be written as follows:

$$
y_i \sim \text{Poisson}(\mu)\\
\ln \mu = \alpha
$$

What is reported in the Poisson glm (`Estimate` `r round(fit_pois$coefficients, 2)`) corresponds to the parameter $\alpha$ ($\mu = \exp(\alpha) > 0$).

## Modeling non-uniform mean

### Single-mean model does not explain

The above model is super simple -- just a single mean $\mu$ is good enough to express how fish are distributed in a lake. In nature, however, this scenario would be very unlikely. For example, fish may be densely distributed near shores (littoral zone) while sparsely distributed at the center (limnetic zone). Now, let's think about the scenario where we collected fish in littoral and limnetic zones, and the data looked like:

```{r df_zone, include=F}

set.seed(1)
df_zone <- tibble(habitat = rep(c("littoral", "limnetic"), each = 10),
                  count = c(rpois(n = 10, lambda = 20),
                            rpois(n = 10, lambda = 5)))

```

```{r df_zone-print}

print(df_zone, n = 20)
```

> **Exercise:** Create a data frame `df_zone` with `tibble()`

Let's take a look at the histogram with this data:

```{r zone-hist, echo = TRUE, fig.cap="Fish count distribution by zone"}

df_zone %>% 
  ggplot(aes(x = count,
             color = habitat, # color by habitat
             fill = habitat)) + # fill by habitat
  geom_histogram(binwidth = 0.1, # change bin-width
                 center = 0) + # shift bin's center
  theme_bw() + # set theme
  labs(y = "Frequency", # y label
       x = "Fish count", # x label
       color = "Habitat", # color label title
       fill = "Habitat") # fill label title
```

If we overlay the expected frequency from a Poisson distribution with the single mean (Figure \@ref(fig:zone-poisson-single-mu)):

```{r zone-poisson-single-mu, echo = TRUE, fig.cap="Poor fit of a Poisson distribution with a single mean"}

# frequency expected from a Poisson distribution
df_p <- tibble(x = seq(min(df_zone$count), max(df_zone$count)), # from min to max count in the data
               prob = dpois(x, lambda = mean(df_zone$count)), # expected probability from a poisson distribution with mean (lambda) = mean(df_zone$count)
               freq = prob * nrow(df_zone)) # convert probability to frequency

# add expected values
df_zone %>% 
  ggplot() +
  geom_histogram(aes(x = count,
                     color = habitat,
                     fill = habitat),
                 binwidth = 0.1,
                 center = 0) +
  geom_line(data = df_p, # add line for expected values
            aes(x = x,
                y = freq),
            col = grey(0.8)) +
  geom_point(data = df_p, # add points for expected values
             aes(x = x,
                 y = freq),
             col = grey(0.6)) +
  theme_bw() +
  labs(y = "Frequency",
       x = "Fish count",
       color = "Habitat",
       fill = "Habitat")
```

Apparently, the Poisson distribution with a single mean does not express the data properly.

### Two-mean model

From the histogram, it is clear that more fish are found in a littoral zone. How can we express this pattern through modeling? One option is to assume different means for littoral and limnetic zones. Let $z(i)$ denote the zone $z$ to which plot $i$ belong -- therefore, $z(i)$ is either "littoral" or "limnetic." If we use this expression, the two-mean model would be:

$$
y_i \sim \text{Poisson}(\mu_{z(i)})\\
\log \mu_{z(i)} = \alpha_{z(i)}
$$

In this equation, the fish count $y_i$ follows a Poisson distribution with mean $\mu_{z(i)}$. The difference from the previous single-mean model is the subscript associated with the mean (i.e., $\mu_{z(i)}$). This means that the mean varies by zone $z$. We can express this equation using the information in the column `habitat` in the data frame `df_zone`:

```{r glm-two-mean, echo = TRUE}

fit_2mu <- glm(count ~ habitat - 1, # "-1" removes intercept from the model
               family = "poisson", # poisson distribution
               data = df_zone) # data from df_zone

summary(fit_2mu)
```

Let's take a look at `Estimate` under `Coefficients:` again. The row `habitatlimnetic` says `r round(fit_2mu$coefficients[1] , 2)` and `habitatlittoral` says `r round(fit_2mu$coefficients[2], 2)`. Remember, these values are reported in a natural log-scale. Once we back-transform these values to an ordinary scale, they should correspond to the means in limnetic and littoral zones respectively. How does the prediction look like if we apply these means to produce the histogram?

```{r hist-2mean, fig.cap="Two-mean model"}

# prepare variables & parameters
mu1 <- exp(fit_2mu$coefficients[1]) # limnetic mean
mu2 <- exp(fit_2mu$coefficients[2]) # littoral mean
x <- seq(min(df_zone$count), max(df_zone$count), by = 1) # observed count values
n_x <- df_zone %>% # sample size for each zone
  group_by(habitat) %>% 
  summarize(n = n()) %>% 
  pull(n) %>% 
  unique()

# expected frequency
df_p_2mu <- tibble(habitat = rep(c("limnetic", "littoral"),
                                 each = length(x)),
                   prob = c(dpois(x, lambda = mu1), # expected prob with mu1
                            dpois(x, lambda = mu2)), # expected prob with mu2
                   freq = prob * n_x) %>% 
  mutate(x = rep(x, 2))

# histogram
df_zone %>% 
  ggplot() +
  geom_histogram(aes(x = count,
                     color = habitat,
                     fill = habitat),
                 binwidth = 0.1,
                 center = 0) +
  geom_line(data = df_p_2mu, # add line for expected values
            aes(x = x,
                y = freq,
                color = habitat)) +
  geom_point(data = df_p_2mu, # add points for expected values
             aes(x = x,
                 y = freq,
                 color = habitat)) +
  theme_bw() +
  labs(y = "Frequency",
       x = "Fish count",
       color = "Habitat",
       fill = "Habitat")
```

This looks much better!

> **Exercise:** Produce the above figure
